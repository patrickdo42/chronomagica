"use client";import { useEffect, useState, useMemo } from "react";import Clock, { useNow } from "@/components/Clock";import * as Astronomy from "@/components/astronomy"; // Import the astronomy libraryinterface PlanetaryHour {  hour: number;  planet: string;  startTime: string;  endTime: string;  symbol: string;  color: string;}interface PlanetInfo {  name: string;  symbol: string;  zodiac: string;  zodiacSymbol: string;  isRetrograde: boolean;  highlightClass: string;}const CHALDEAN_ORDER = ["Saturn", "Jupiter", "Mars", "Sol", "Venus", "Mercury", "Luna"];const PLANET_SYMBOLS: Record<string, string> = {  Sol: "&#9737;",  Luna: "&#9789;",  Mars: "&#9794;",  Mercury: "&#9791;",  Jupiter: "&#9795;",  Venus: "&#9792;",  Saturn: "&#9796;",  Uranus: "&#9797;",  Neptune: "&#9798;",  Pluto: "&#9935;",};const PLANET_COLORS: Record<string, string> = {  Sol: "#FFD700", // Gold  Luna: "#C0C0C0", // Silver  Mars: "#FF4500", // OrangeRed  Mercury: "#ADD8E6", // LightBlue  Jupiter: "#DAA520", // Goldenrod  Venus: "#EE82EE", // Violet  Saturn: "#BDB76B", // DarkKhaki  Uranus: "#AFEEEE", // PaleTurquoise  Neptune: "#6495ED", // CornflowerBlue  Pluto: "#DDA0DD", // Plum};const ZODIAC_SIGNS: string[] = [  "Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo",  "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces"];const ZODIAC_SYMBOLS: Record<string, string> = {  Aries: "&#9800;",  Taurus: "&#9801;",  Gemini: "&#9802;",  Cancer: "&#9803;",  Leo: "&#9804;",  Virgo: "&#9805;",  Libra: "&#9806;",  Scorpio: "&#9807;",  Sagittarius: "&#9808;",  Capricorn: "&#9809;",  Aquarius: "&#9810;",  Pisces: "&#9811;",};const getZodiacSign = (eclipticLongitude: number): { name: string; symbol: string } => {  const index = Math.floor(eclipticLongitude / 30);  const name = ZODIAC_SIGNS[index % 12];  const symbol = ZODIAC_SYMBOLS[name];  return { name, symbol };};const MOON_PHASE_ICONS: Record<string, string> = {  "New Moon": "ðŸŒ‘",  "Waxing Crescent": "ðŸŒ’",  "First Quarter": "ðŸŒ“",  "Waxing Gibbous": "ðŸŒ”",  "Full Moon": "ðŸŒ•",  "Waning Gibbous": "ðŸŒ–",  "Third Quarter": "ðŸŒ—",  "Waning Crescent": "ðŸŒ˜",};const getMoonPhaseName = (phaseAngle: number): string => {  if (phaseAngle < 22.5) return "New Moon";  if (phaseAngle < 67.5) return "Waxing Crescent";  if (phaseAngle < 112.5) return "First Quarter";  if (phaseAngle < 157.5) return "Waxing Gibbous";  if (phaseAngle < 202.5) return "Full Moon";  if (phaseAngle < 247.5) return "Waning Gibbous";  if (phaseAngle < 292.5) return "Third Quarter";  if (phaseAngle < 337.5) return "Waning Crescent";  return "New Moon";};export default function Home() {  const [planetaryHours, setPlanetaryHours] = useState<PlanetaryHour[]>([]);  const [currentPlanetaryHour, setCurrentPlanetaryHour] = useState<PlanetaryHour | null>(null);  const [sunriseTime, setSunriseTime] = useState<Date | null>(null);  const [sunsetTime, setSunsetTime] = useState<Date | null>(null);  // Single-page layout: remove tabs, always show all sections  const [moonPhase, setMoonPhase] = useState<{ name: string; icon: string } | null>(null);  const [planetData, setPlanetData] = useState<PlanetInfo[]>([]);  const now = useNow(1000); // Using the useNow hook from Clock component  const getDayOfWeek = (date: Date): number => {    return date.getDay(); // Sunday - 0, Monday - 1, etc.  };  const getStartingPlanet = (dayOfWeek: number): string => {    // Sunday (0) starts with Sol, Monday (1) with Luna, etc.    const dayToPlanetMap: Record<number, string> = {      0: "Sol",    // Sunday      1: "Luna",   // Monday      2: "Mars",   // Tuesday      3: "Mercury",// Wednesday      4: "Jupiter",// Thursday      5: "Venus",  // Friday      6: "Saturn", // Saturday    };    return dayToPlanetMap[dayOfWeek];  };  const calculatePlanetaryHours = (    sunrise: Date,    sunset: Date,    startingPlanet: string,    locale?: string,    timeZone?: string  ): PlanetaryHour[] => {    const hours: PlanetaryHour[] = [];    const dayDuration = sunset.getTime() - sunrise.getTime(); // in milliseconds    const nightDuration = (sunrise.getTime() + 24 * 60 * 60 * 1000) - sunset.getTime(); // until next sunrise    const dayHourLength = dayDuration / 12; // in milliseconds    const nightHourLength = nightDuration / 12; // in milliseconds    const planetOrder = [...CHALDEAN_ORDER];    let startIndex = planetOrder.indexOf(startingPlanet);    if (startIndex === -1) startIndex = 0; // Default to Saturn if not found    const getPlanetForHour = (hourIndex: number) => {      return planetOrder[(startIndex + hourIndex) % planetOrder.length];    };    // Day hours    for (let i = 0; i < 12; i++) {      const hourStartTime = new Date(sunrise.getTime() + i * dayHourLength);      const hourEndTime = new Date(sunrise.getTime() + (i + 1) * dayHourLength);      const planet = getPlanetForHour(i);      hours.push({        hour: i + 1,        planet,        startTime: hourStartTime.toLocaleTimeString(locale, { hour: 'numeric', minute: '2-digit', hour12: true, timeZone }),        endTime: hourEndTime.toLocaleTimeString(locale, { hour: 'numeric', minute: '2-digit', hour12: true, timeZone }),        symbol: PLANET_SYMBOLS[planet] || "",        color: PLANET_COLORS[planet] || "#FFFFFF",      });    }    // Night hours (from sunset to next sunrise)    for (let i = 0; i < 12; i++) {      const hourStartTime = new Date(sunset.getTime() + i * nightHourLength);      const hourEndTime = new Date(sunset.getTime() + (i + 1) * nightHourLength);      const planet = getPlanetForHour(i + 12); // Continue the cycle      hours.push({        hour: i + 13, // Hours 13-24        planet,        startTime: hourStartTime.toLocaleTimeString(locale, { hour: 'numeric', minute: '2-digit', hour12: true, timeZone }),        endTime: hourEndTime.toLocaleTimeString(locale, { hour: 'numeric', minute: '2-digit', hour12: true, timeZone }),        symbol: PLANET_SYMBOLS[planet] || "",        color: PLANET_COLORS[planet] || "#FFFFFF",      });    }    return hours;  };  useEffect(() => {    const fetchSunriseSunset = async () => {      const dateString = now.toISOString();      // Default observer location (e.g., Chicago) - can be made dynamic later      const observer = {        latitude: 41.8781,        longitude: -87.6298,        height: 180, // meters above sea level      };      // Fetch sunrise for Sol      const sunriseRes = await fetch(        `/api/sunrise-sunset?latitude=${observer.latitude}&longitude=${observer.longitude}&height=${observer.height}&body=Sol&date=${dateString}&direction=1`      );      const sunriseData = await sunriseRes.json();      const srTime = sunriseData.time ? new Date(sunriseData.time) : null;      setSunriseTime(srTime);      // Fetch sunset for Sol      const sunsetRes = await fetch(        `/api/sunrise-sunset?latitude=${observer.latitude}&longitude=${observer.longitude}&height=${observer.height}&body=Sol&date=${dateString}&direction=-1`      );      const sunsetData = await sunsetRes.json();      const ssTime = sunsetData.time ? new Date(sunsetData.time) : null;      setSunsetTime(ssTime);    };    fetchSunriseSunset();  }, [now]);  useEffect(() => {    if (sunriseTime && sunsetTime) {      const dayOfWeek = getDayOfWeek(now);      const startingPlanet = getStartingPlanet(dayOfWeek);      const calculatedHours = calculatePlanetaryHours(sunriseTime, sunsetTime, startingPlanet);      setPlanetaryHours(calculatedHours);    }  }, [now, sunriseTime, sunsetTime]);  useEffect(() => {    const currentHour = planetaryHours.find((hour) => {      const start = new Date(hour.startTime);      const end = new Date(hour.endTime);      return now >= start && now < end;    });    setCurrentPlanetaryHour(currentHour || null);  }, [now, planetaryHours]);  useEffect(() => {    const fetchPlanetAndMoonData = async () => {      const dateString = now.toISOString();      const astronomyTime = Astronomy.MakeTime(now);      // Fetch moon phase      const moonPhaseAngle = Astronomy.MoonPhase(astronomyTime);      const phaseName = getMoonPhaseName(moonPhaseAngle);      setMoonPhase({ name: phaseName, icon: MOON_PHASE_ICONS[phaseName] || " " });      // Fetch planet data (retrograde and zodiac)      const planetsToFetch = [        "Sol", "Luna", "Mercury", "Venus", "Mars", "Jupiter",        "Saturn", "Uranus", "Neptune", "Pluto"      ];      const fetchedPlanetData: PlanetInfo[] = [];      for (const planetName of planetsToFetch) {        let isRetrograde = false;        if (planetName !== "Sol" && planetName !== "Luna") {          const retrogradeRes = await fetch(`/api/planet-retrograde?body=${planetName}&date=${dateString}`);          const retrogradeData = await retrogradeRes.json();          isRetrograde = retrogradeData.isRetrograde;        }        const helioVector = Astronomy.HelioVector(Astronomy.Body[planetName as keyof typeof Astronomy.Body], astronomyTime);        const ecliptic = Astronomy.Ecliptic(helioVector);        const { name: zodiacName, symbol: zodiacSymbol } = getZodiacSign(ecliptic.elon);        fetchedPlanetData.push({          name: planetName,          symbol: PLANET_SYMBOLS[planetName] || "",          zodiac: zodiacName,          zodiacSymbol: zodiacSymbol,          isRetrograde: isRetrograde,          highlightClass: `${planetName.toLowerCase()}-highlight`,        });      }      setPlanetData(fetchedPlanetData);    };    fetchPlanetAndMoonData();  }, [now]);  return (    <main className="page-container">      <h1 className="energies-title">Today&#8217;s Energies</h1>      <div className="header-section">        <div className="header-left">          <p className="header-date">Wednesday, June 26, 2025</p>          <p className="header-location">Metairie, LA</p>        </div>        <div className="header-right">          <p className="header-time">1:09 PM</p>          <p className="header-weather">90Â° F, Partly Cloudy <img src="/weather-icon.svg" alt="Partly Cloudy" /></p>        </div>      </div>      <div className="content-section">        <table className="planetary-info-table" aria-label="Planetary Information">          <tbody>            {planetData.map((planet) => (              <tr key={planet.name} className={planet.highlightClass}>                <td>                  {planet.name} <span dangerouslySetInnerHTML={{ __html: planet.symbol }}></span>                </td>                <td>                  {planet.isRetrograde ? (                    <span className="retrograde-text">Retrograde</span>                  ) : (                    planet.name === "Luna" ? "New Moon" : ""                  )}                </td>                <td>                  {planet.zodiac} <span className="zodiac-symbol" dangerouslySetInnerHTML={{ __html: planet.zodiacSymbol }}></span>                </td>              </tr>            ))}          </tbody>        </table>        <table className="hours-table" aria-label="Planetary hours">          <tbody>            {planetaryHours.map((ph) => (              <tr                key={ph.hour}                className={currentPlanetaryHour?.hour === ph.hour ? "current" : ""}                style={currentPlanetaryHour?.hour === ph.hour ? { backgroundColor: ph.color, color: "white" } : {}}              >                <td>{ph.hour}</td>                <td>                  {ph.startTime} - {ph.endTime}                </td>                <td>                  {ph.planet} <span dangerouslySetInnerHTML={{ __html: ph.symbol }}></span>                </td>              </tr>            ))}          </tbody>        </table>      </div>      <p className="lucky" style={{ textAlign: "center", fontSize: "1.4rem", marginTop: 16 }}>        Today is lucky.      </p>    </main>  );}